# Java内存区域与溢出异常

<br/> 

### 1. 运行时数据区域
### 2. HotSpot虚拟机对象探秘
### 3. 实战：OutOfMemoryErorr异常

<br/> 

### 1. 运行时数据区域
##### 1.1 程序计数器（Program Counter Register）（线程私有）
程序计数器是一块较小的空间，它可以看作是当前线程所执行的字节码的行号**指示器**。在Java虚拟机的概念模型里，字节码解释器工作时就是要通过改变这个计数器的值来**选取下一条需要执行的字节码指令**，它是程序控制流的**指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实线的（在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令）。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为**线程私有**的内存。

##### 1.2 Java虚拟机栈（Java Virtual Machine Stacks）（线程私有）
与程序计数器一样，同为**线程私有**。它的生命周期与线程周期相同。虚拟机栈描述的是Java**方法**执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。*每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。*

##### 1.3 本地方法栈（Native Method Stacks）（线程私有）
本地方法栈（Native Method Stacks）与虚拟机栈发挥的作用非常相似。区别：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地方法（Native Methods）提供服务。

###### 1.3.1 Java方法 vs 本地方法
**Java方法**：是由java语言编写，编译成字节码，存储在class文件中的。java方法是与平台无关的。
**本地方法**：本地方法是由其他语言（如C、C++ 或其他汇编语言）编写，编译成和处理器相关的代码。本地方法保存在动态连接库中，格式是各个平台专用的，运行中的java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库，并调用这个方法。通过本地方法，java程序可以直接访问底层操作系统的资源，但是这么用的话，程序就变成了平台相关了，因为本地方法的动态库是与平台相关的，此外，使用本地方法还可能把程序变得和特定的java平台实现相关。

**为什么用本地方法**：
1. java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。
2. 与java环境外交互：
   有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。
3. 与操作系统交互：
   JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

##### 1.4 Java堆（Java Virtual Machine Heap）（线程共享）
Java堆（Java Heap）是虚拟机所管理的内存中**最大**的一块。Java堆被所有线程共享，在虚拟机启动时创建。它的唯一目的：**存放对象实例**。所有的对象实例以及数组都应当在堆上分配。
Java堆是**垃圾收集器管理的内存区域**，也被称作“GC堆”（Garbage Collection Heap）。
将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。
Java堆可以处于*物理*上**不连续**的内存空间中，但在*逻辑*上它应该被视为**连续**的。

##### 1.5 方法区（Method Area）（线程共享）
方法区与Java堆一样，是各个**线程共享的内存区域**。用于存储已经被虚拟机加载的：类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。一般来说，这个区域的回收效果比较难令人满意，尤其是类型卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

##### 1.6 运行时常量池（Runtime Constant Pool）（线程共享）
运行时常量池是*方法区的一部分*。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池表**（Const Pool Table），用于存放编译期生成的各种字面量与符号信息。这部分内容将在类加载后存放到方法取得运行时常量池中。具备动态性，用的比较多的就是String类的intern()方法。    

##### 字符串常量池
###### 实例化字符串常量池
```java
String str1 = “hello”;
String str2 = “hello”;

System.out.printl（"str1 == str2" : str1 == str2 ) //true
```
###### 创建字符串对象
```java
// Create three strings in three different ways.
String s1 = "Hello";
String s2 = new StringBuffer("He").append("llo").toString();
String s3 = s2.intern();

// Determine which strings are equivalent using the ==
// operator
System.out.println("s1 == s2? " + (s1 == s2)); // false
System.out.println("s1 == s3? " + (s1 == s3)); // true
```

##### 1.7 直接内存（Direct Memory）
它并不是虚拟机运行时数据区的一部分，也不是JAVA虚拟机规范中定义的内存区域。在JDK1.4中加入了NIO类，引入了一种基于通道(Channel)于缓冲区(Buffer)的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在JAVA堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在JAVA堆中和Native堆中来回复制数据。

<br/> 

### 2. HotSpot虚拟机对象探秘
深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程
##### 2.1 对象的创建
当Java虚拟机遇到一条```new```指令时：
1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用
    a. 检查这个类的符号引用代表的类是否已经被加载、解析和初始化过
    b. 如果没有，则必须先执行相应的类的加载过程
2. 虚拟机将为新生对象分配内存（对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上等同于把一块确定大小的内存块从Java堆中划分出来（Java堆是专门存放对象实例的））
3. 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头，对象头内容会在后面“对象的内存布局讲到”）。这步操作保证了对象的实例字段在Java代码中可以**不赋初值就直接使用**，使程序能访问到这些字段的数据类所对应的零值。
4. 接下来Java虚拟机还需要对对象进行必要的设置。

上述工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了；但是从Java程序的角度，对象的创建才刚刚开始----构造函数，即Class文件中的\<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。

**关于如何分配内存**：
A. **指针碰撞**（Bump The Pointer）：假设Java堆中的内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器。分配内存仅仅就是把指针向空闲空间挪动一段与对象大小相等的距离。
B. **空闲列表**（Free List）：假如Java堆中的内存不是规整的，而是使用过的和未使用过的交错在一起，就不能使用碰撞指针，虚拟机必须维护一个列表，记录哪些内存块是可用的（和操作系统非常相像）
选择哪种分配方式取决于**Java堆是否规整**，而Java堆是否规整又取决于**所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力**。

对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发的情况下也并不是线程安全的。解决办法：
A. 对分配内存空间的动作进行**同步处理**,实际上虚拟机采用的是CAS配上失败重试的方式保证更新操作的**原子性**。
B. 把内存分配的动作按照线程划分在**不同的空间**之中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）**，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。这减少了同步锁定操作，但同时会造成空间的浪费。

##### 2.2 对象的内存布局
在HotSpot虚拟机里，对象在**堆**（Java堆）内存中的存储布局可以划分为三个部分：
1. 对象头（Header）
2. 实例数据（Instance Data）
3. 对齐填充（Padding）

**对象头**
对象头部分包括两类信息：
1. 对象自身的运行时数据，如哈希码（HashCode）、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称他们为“Mark Word”。对象头里的信息是**与对象自身定义的数据无关的额外存储成本**。考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间（这句话看得有点懵）。
2. 类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。如果对象是一个Java**数组**，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的**大小**，但如果**数组的长度**是不确定的，将无法通过元数据中的信息推断出**数组的大小**。

**实例数据**
实例数据部分是对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容。

**对齐填充**
并不是必然存在的，也没有特别含义，仅仅起到占位符的作用。 

##### 2.2 对象的内存布局
Java程序会通过**栈**上的**reference数据**来操作**堆**上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个**指向对象的引用**，并没有指定这个引用通过什么方式去定位、访问到堆中的对象的具体位置，所以**对象的访问方式**也是由虚拟机实现而定的，主流的访问方式主要有使用**句柄**和**直接指针**两种：

* **句柄访问**：Java堆（存放实例对象）会划分出一块内存来作为句柄池，refence中存储的就是对象的句柄池地址，而句柄中包含了对象**实例数据**与**类型数据**各自的**地址信息**。
![通过句柄访问对象](https://img-blog.csdnimg.cn/20200412115610137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05fYV9u,size_16,color_FFFFFF,t_70)
**优点**：reference中存储的是稳定的句柄地址。改变时也只会改变句柄中的实例数据地址，reference本身不变。当有多个reference指向同一个句柄时，只需要改变一个句柄地址，效率高。
**缺点**：定位对象时，需要两次定位，时间开销高。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

</br>

* **直接指针**：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是**对象地址**，当访问对象本身时，无需多一次间接访问的开销。
![通过直接指针访问对象](https://img-blog.csdnimg.cn/20200412115610137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05fYV9u,size_16,color_FFFFFF,t_70)
**优点**：定位速度块，一次定位。
**缺点**：当对象被移动时，所有指向该对象的reference都需要修改，耗时。

### 3. 实战：OutOfMemoryErorr异常
##### 3.1 Java堆溢出
Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示"Java heap space"。
要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具堆Dump出来的堆转储快照进行分析。第一步首先确定**内存中导致OOM的对象是否必要**，也就是要分清楚到底是出现了**内存泄漏**（Memory Leak，垃圾收集器无法回收他们）还是**内存溢出**（Memory Overflow）。

如果不是内存泄漏，那么内存中的对象确实都是必须存活的，那就应当与机器内存对比，看看是否还有向上调整的空间，再检查是否**对象的生命周期过长**，**持有状态时间过长**，**存储结构不合理**，尽量减少程序运行时期的内存消耗。



